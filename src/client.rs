// src/client.rs - A gRPC client implementation using Tonic for Rust

// Import StreamExt trait for working with streams (provides methods like next())
use futures_util::StreamExt;

// Import mpsc (multi-producer, single-consumer) channel for async communication
use tokio::sync::mpsc;

// Import wrapper to convert channel receivers into streams
use tokio_stream::wrappers::ReceiverStream;

// Import Channel from tonic for gRPC connection handling
use tonic::transport::Channel;

// Import generated protobuf code for the client
use echo::echo_service_client::EchoServiceClient; // Client for the EchoService
use echo::EchoRequest; // The request message type defined in proto

// Include the generated protobuf code
// This macro includes code generated by tonic-build based on your .proto file
pub mod echo {
    tonic::include_proto!("echo"); // Expands to the code generated from the "echo" package in your proto file
}

// === UNARY RPC IMPLEMENTATION ===
// This function demonstrates a simple request-response pattern
// A single request is sent, and a single response is received
async fn unary_call(
    client: &mut EchoServiceClient<Channel>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Create a new request object with a message
    let request = tonic::Request::new(EchoRequest {
        message: String::from("Hello from client"),
    });
    
    // Send the request to the server and await the response
    // The ? operator will propagate any errors that occur
    let response = client.echo(request).await?;
    
    // Print the response after extracting the inner message using into_inner()
    // into_inner() consumes the response and returns just the response payload
    println!("RESPONSE: {:?}", response.into_inner());
    
    // Return Ok to indicate success
    Ok(())
}

// === SERVER STREAMING IMPLEMENTATION ===
// This function demonstrates server streaming
// The client sends a single request, and the server responds with a stream of messages
async fn server_streaming(
    client: &mut EchoServiceClient<Channel>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Create a new request object
    let request = tonic::Request::new(EchoRequest {
        message: String::from("Stream me some responses"),
    });
    
    // Send the request and get back a stream of responses
    // into_inner() extracts the actual response stream from the tonic Response
    let mut stream = client.server_stream(request).await?.into_inner();
    
    // Process each response in the stream until it's exhausted
    // stream.next().await returns Option<Result<EchoResponse, Status>>
    // - Some(result) means we got something (either Ok or Err)
    // - None means the stream has ended
    while let Some(response) = stream.next().await {
        // Handle each response using pattern matching
        match response {
            Ok(msg) => println!("SERVER STREAM RESPONSE: {:?}", msg), // Successfully received a message
            Err(e) => println!("SERVER STREAM ERROR: {:?}", e),       // Error receiving a message
        }
    }
    
    // Return Ok to indicate success
    Ok(())
}

// === CLIENT STREAMING IMPLEMENTATION ===
// This function demonstrates client streaming
// The client sends multiple messages, and the server responds with a single message
async fn client_streaming(
    client: &mut EchoServiceClient<Channel>,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("Starting client streaming");
    
    // Create a channel for sending messages
    // mpsc::channel(10): Creates a channel with a buffer size of 10 messages
    // tx: Transmitter (sender) side of the channel
    // rx: Receiver side of the channel
    let (tx, rx) = mpsc::channel(10);
    
    // Convert the receiver into a stream that tonic can use
    // ReceiverStream wraps the receiver in a Stream implementation
    let stream = ReceiverStream::new(rx);
    
    // Create a request that contains the stream
    // The server will receive messages from this stream
    let request = tonic::Request::new(stream);
    
    // Start the client_stream RPC but don't await it yet
    // This returns a Future that will complete when the server sends its response
    // Important: We start this before sending messages so the server can process them as they arrive
    let response_future = client.client_stream(request);
    
    // Send multiple messages through the channel
    for i in 1..=5 {
        // Create a new message with a counter
        let msg = EchoRequest {
            message: format!("Client message {}", i),
        };
        
        // Log that we're sending a message
        println!("Sending message {}", i);
        
        // Send the message through the channel and await completion
        // The ? operator will propagate any errors from the send operation
        tx.send(msg).await?;
        
        // Log that the message was sent successfully
        println!("Sent client message {}", i);
        
        // Wait a short time before sending the next message
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
    
    // Log that we're finishing the stream
    println!("Dropping sender to signal end of stream");
    
    // Explicitly drop the sender to signal to the server that no more messages will be sent
    // This is important for client streaming - it tells the server the stream is complete
    drop(tx);
    
    // Now that we've sent all messages and closed the stream, await the server's response
    println!("Waiting for response...");
    let response = response_future.await?;
    
    // Print the response
    println!("CLIENT STREAM RESPONSE: {:?}", response.into_inner());
    
    // Return Ok to indicate success
    Ok(())
}

// === BIDIRECTIONAL STREAMING IMPLEMENTATION ===
// This function demonstrates bidirectional streaming
// Both the client and server send multiple messages to each other
async fn bidirectional_streaming(
    client: &mut EchoServiceClient<Channel>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Create a channel for sending messages with a buffer of 4
    let (tx, rx) = mpsc::channel(4);
    
    // Convert the receiver to a stream
    let stream = ReceiverStream::new(rx);
    
    // Create a request with the stream
    let request = tonic::Request::new(stream);
    
    // Start the bidirectional stream and get the response stream
    let mut response_stream = client.bidirectional_stream(request).await?.into_inner();
    
    // Create a task to send messages to the server
    // This runs concurrently with receiving messages
    let sender_task = tokio::spawn(async move {
        for i in 1..=5 {
            // Create a message with a counter
            let msg = EchoRequest {
                message: format!("Bidirectional message {}", i),
            };
            
            // Send the message and handle any errors
            // Unlike previous examples, we handle the error directly here
            match tx.send(msg).await {
                Ok(_) => println!("Sent message {}", i), // Successfully sent
                Err(e) => {
                    // Failed to send (likely receiver dropped)
                    println!("Failed to send message: {:?}", e);
                    break; // Exit the loop if we can't send
                }
            }
            
            // Wait a second before sending the next message
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        }
        // tx is automatically dropped when this task completes, signaling end of stream
    });
    
    // Create a task to receive messages from the server
    // This runs concurrently with sending messages
    let receiver_task = tokio::spawn(async move {
        // Process each response as it arrives
        while let Some(response) = response_stream.next().await {
            match response {
                Ok(msg) => println!("BIDIRECTIONAL RESPONSE: {:?}", msg), // Successfully received
                Err(e) => {
                    // Error receiving (likely server error or disconnection)
                    println!("BIDIRECTIONAL STREAM ERROR: {:?}", e);
                    break; // Exit the loop on error
                }
            }
        }
        // Stream is exhausted when this loop exits
    });
    
    // Wait for both tasks to complete
    // tokio::try_join! will propagate any errors from either task
    tokio::try_join!(sender_task, receiver_task)?;
    
    // Return Ok to indicate success
    Ok(())
}

// The main function - entry point of the program
// #[tokio::main]: Macro that sets up the Tokio runtime for async code
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a channel to connect to the server
    // from_static creates a channel from a static string URL
    // connect() establishes the connection
    let channel = tonic::transport::Channel::from_static("http://[::1]:50051")
        .connect()
        .await?;
    
    // Create a new client using the channel
    let mut client = EchoServiceClient::new(channel);
    
    // Run each RPC type in sequence
    println!("\n=== Unary Call ===");
    unary_call(&mut client).await?;
    
    println!("\n=== Server Streaming ===");
    server_streaming(&mut client).await?;
    
    println!("\n=== Client Streaming ===");
    client_streaming(&mut client).await?;
    
    println!("\n=== Bidirectional Streaming (WebSocket-like) ===");
    bidirectional_streaming(&mut client).await?;
    
    // Return Ok if everything completed successfully
    Ok(())
}
